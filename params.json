{"name":"Django-hstore","tagline":"Fork of django-hstore to support automatic JSON serialization of dictionary values.","body":"# django-hstore\r\n\r\nDjango-hstore is a niche library which integrates the [hstore](http://www.postgresql.org/docs/9.0/interactive/hstore.html) extension of PostgreSQL into Django.\r\n\r\nDependencies:\r\n\r\n* **Django 1.2+**\r\n* **PostgreSQL 9.0+**\r\n* **Psycopg 2.3+**.\r\n\r\n## Fork features\r\n\r\nThis fork aims to:\r\n\r\n* support data-types beyond strings.  To do so, all values entered in to / retrived from django-hstore are serialized to / from JSON.\r\n* This fork aims to support spatial querysets. Now supported only Postgis backend.\r\n\r\n\r\n### Summary of work\r\n\r\n* All data entered in to a `hstore.DictionaryField` is serialized upon entrance into the db via its `get_prep_value()` method and unserialized upon retrieval via its `to_python()` method.\r\n* When declaring the `django_hstore.hstore.Manager` field, you can optionally pass in a tuple of fieldname strings indicating which fields are of type `hstoreDictionaryField`. This allows the object manager to serialize any arguments provided when using the `filter` or `exclude` method of the `django_hstore.hstore.Manager` object.\r\n\r\n## Limitations\r\n\r\n- Due to how Django implements its ORM, you will need to use the custom ``postgresql_psycopg2`` backend\r\n  defined in this package, which naturally will prevent you from dropping in other django extensions\r\n  which require a custom backend (unless you fork and combine).\r\n- PostgreSQL's implementation of hstore has no concept of type; it stores a mapping of string keys to\r\n  string values. ~~This library makes no attempt to coerce keys or values to strings.~~ As such, this library encodes all values to JSON.\r\n\r\n## Running the tests\r\n\r\nAssuming one has the dependencies installed, and a **PostgreSQL 9.0+** server up and\r\nrunning::\r\n\r\n    python setup.py test\r\n\r\nYou might need to tweak the DB settings according to your DB configuration.\r\nYou can copy the file settings.py and create **local_settings.py**, which will\r\nbe used instead of the default settings.py.\r\n\r\nIf after running this command you get an **error** saying::\r\n    \r\n    type \"hstore\" does not exist\r\n\r\nTry this::\r\n\r\n    psql template1 -c 'create extension hstore;'\r\n\r\nMore details here: [PostgreSQL error type hstore does not exist](http://clarkdave.net/2012/09/postgresql-error-type-hstore-does-not-exist/)\r\n\r\n## Usage\r\n\r\nFirst, update your settings module to specify the custom database backend::\r\n\r\n    DATABASES = {\r\n        'default': {\r\n            'ENGINE': 'django_hstore.backends.postgresql_psycopg2',\r\n            # or\r\n            # 'ENGINE': 'django_hstore.backends.postgis',\r\n            ...\r\n        }\r\n    }\r\n\r\n**Note to South users:** If you keep getting errors like `There is no South\r\ndatabase module 'south.db.None' for your database.`, add the following to\r\n`settings.py`::\r\n\r\n    SOUTH_DATABASE_ADAPTERS = {'default': 'south.db.postgresql_psycopg2'}\r\n\r\nThe library provides three principal classes:\r\n\r\n* ``django_hstore.hstore.DictionaryField``\r\n    * An ORM field which stores a mapping of string key/value pairs in an hstore column.\r\n* ``django_hstore.hstore.ReferencesField``\r\n    * An ORM field which builds on DictionaryField to store a mapping of string keys to django object references, much like ForeignKey.\r\n* ``django_hstore.hstore.Manager``\r\n    * An ORM manager which provides much of the query functionality of the library.\r\n\r\nModel definition is straightforward::\r\n\r\n    from django.db import models\r\n    from django_hstore import hstore\r\n\r\n    class Something(models.Model):\r\n        name = models.CharField(max_length=32)\r\n        data = hstore.DictionaryField(db_index=True)\r\n        objects = hstore.Manager()\r\n\r\n        def __unicode__(self):\r\n            return self.name\r\n\r\nYou then treat the ``data`` field as simply a dictionary of string pairs::\r\n\r\n    instance = Something.objects.create(name='something', data={'a': 1, 'b': '2'})\r\n    assert instance.data['a'] == 1\r\n\r\n    empty = Something.objects.create(name='empty')\r\n    assert empty.data == {}\r\n\r\n    empty.data['a'] = 1\r\n    empty.save()\r\n    assert Something.objects.get(name='something').data['a'] == 1\r\n\r\nYou can issue indexed queries against hstore fields::\r\n\r\n    # equivalence\r\n    Something.objects.filter(data={'a': 1, 'b': '2'})\r\n\r\n    # comparision\r\n    Something.objects.filter(data__gt={'a': 1})\r\n    Something.objects.filter(data__gte={'a': 1})\r\n    Something.objects.filter(data__lt={'a': '2'})\r\n    Something.objects.filter(data__lte={'a': '2'})\r\n\r\n    # subset by key/value mapping\r\n    Something.objects.filter(data__contains={'a': 1})\r\n\r\n    # subset by list of some key values\r\n    Something.objects.filter(data__contains={'a': [1, '2']})\r\n\r\n    # subset by list of keys\r\n    Something.objects.filter(data__contains=['a', 'b'])\r\n\r\n    # subset by single key\r\n    Something.objects.filter(data__contains='a')\r\n\r\nYou can still do classic django \"contains\" lookups as you would normally do for normal text\r\nfields if you were looking for a particular string. In this case, the HSTORE field\r\nwill be converted to text and the lookup will be performed on all the keys and all the values::\r\n\r\n    Something.objects.create(data={ 'some_key': 'some crazy Value' })\r\n\r\n    # classic text lookup (look up for occurence of string in all the keys)\r\n    Something.objects.filter(data__contains='crazy')\r\n    Something.objects.filter(data__contains='some_key')\r\n    # classic case insensitive text looup\r\n    Something.objects.filter(data__icontains='value')\r\n    Something.objects.filter(data__icontains='SOME_KEY')\r\n\r\nYou can also take advantage of some db-side functionality by using the manager::\r\n\r\n    # identify the keys present in an hstore field\r\n    >>> Something.objects.hkeys(id=instance.id, attr='data')\r\n    ['a', 'b']\r\n\r\n    # peek at a a named value within an hstore field\r\n    >>> Something.objects.hpeek(id=instance.id, attr='data', key='a')\r\n    '1'\r\n\r\n    # do the same, after filter\r\n    >>> Something.objects.filter(id=instance.id).hpeek(attr='data', key='a')\r\n    '1'\r\n\r\n    # remove a key/value pair from an hstore field\r\n    >>> Something.objects.filter(name='something').hremove('data', 'b')\r\n\r\nThe hstore methods on manager pass all keyword arguments aside from ``attr`` and ``key``\r\nto ``.filter()``.\r\n","google":"UA-16401510-7","note":"Don't delete this file! It's used internally to help with page regeneration."}